--- drivers/video/msm/mdp.c
+++ drivers/video/msm/mdp.c
@@ -142,318 +142,16 @@
 #endif
 
 static u32 mdp_irq;
+/* 
+ * Add a global flag to indicate supporting of the feature:
+ * continuous display from app bootloader to kernel/android 
+ */
+#ifdef CONFIG_HUAWEI_KERNEL
+boolean mdp_continues_display = true;
+#endif
 
 static uint32 mdp_prim_panel_type = NO_PANEL;
 #ifndef CONFIG_FB_MSM_MDP22
-
-struct list_head mdp_hist_lut_list;
-DEFINE_MUTEX(mdp_hist_lut_list_mutex);
-
-uint32_t mdp_block2base(uint32_t block)
-{
-	uint32_t base = 0x0;
-	switch (block) {
-	case MDP_BLOCK_DMA_P:
-		base = 0x90000;
-		break;
-	case MDP_BLOCK_DMA_S:
-		base = 0xA0000;
-		break;
-	case MDP_BLOCK_VG_1:
-		base = 0x20000;
-		break;
-	case MDP_BLOCK_VG_2:
-		base = 0x30000;
-		break;
-	case MDP_BLOCK_RGB_1:
-		base = 0x40000;
-		break;
-	case MDP_BLOCK_RGB_2:
-		base = 0x50000;
-		break;
-	default:
-		break;
-	}
-	return base;
-}
-
-static uint32_t mdp_pp_block2hist_lut(uint32_t block)
-{
-	uint32_t valid = 0;
-	switch (block) {
-	case MDP_BLOCK_DMA_P:
-		valid = (mdp_rev >= MDP_REV_40) ? 1 : 0;
-		break;
-	case MDP_BLOCK_DMA_S:
-		valid = (mdp_rev >= MDP_REV_40) ? 1 : 0;
-		break;
-	case MDP_BLOCK_VG_1:
-		valid = (mdp_rev >= MDP_REV_40) ? 1 : 0;
-		break;
-	case MDP_BLOCK_VG_2:
-		valid = (mdp_rev >= MDP_REV_40) ? 1 : 0;
-		break;
-	default:
-		break;
-	}
-	return valid;
-}
-
-static void mdp_hist_lut_init_mgmt(struct mdp_hist_lut_mgmt *mgmt,
-		uint32_t block)
-{
-	mutex_init(&mgmt->lock);
-	mgmt->block = block;
-
-	mutex_lock(&mdp_hist_lut_list_mutex);
-	list_add(&mgmt->list, &mdp_hist_lut_list);
-	mutex_unlock(&mdp_hist_lut_list_mutex);
-}
-
-static int mdp_hist_lut_init(void)
-{
-	struct mdp_hist_lut_mgmt *temp;
-	struct list_head *pos, *q;
-	INIT_LIST_HEAD(&mdp_hist_lut_list);
-
-	if (mdp_rev >= MDP_REV_30) {
-		temp = kmalloc(sizeof(struct mdp_hist_lut_mgmt), GFP_KERNEL);
-		if (!temp)
-			goto exit;
-		mdp_hist_lut_init_mgmt(temp, MDP_BLOCK_DMA_P);
-	}
-
-	if (mdp_rev >= MDP_REV_40) {
-		temp = kmalloc(sizeof(struct mdp_hist_lut_mgmt), GFP_KERNEL);
-		if (!temp)
-			goto exit_list;
-		mdp_hist_lut_init_mgmt(temp, MDP_BLOCK_VG_1);
-
-		temp = kmalloc(sizeof(struct mdp_hist_lut_mgmt), GFP_KERNEL);
-		if (!temp)
-			goto exit_list;
-		mdp_hist_lut_init_mgmt(temp, MDP_BLOCK_VG_2);
-	}
-
-	if (mdp_rev > MDP_REV_42) {
-		temp = kmalloc(sizeof(struct mdp_hist_lut_mgmt), GFP_KERNEL);
-		if (!temp)
-			goto exit_list;
-		mdp_hist_lut_init_mgmt(temp, MDP_BLOCK_DMA_S);
-	}
-	return 0;
-
-exit_list:
-	mutex_lock(&mdp_hist_lut_list_mutex);
-	list_for_each_safe(pos, q, &mdp_hist_lut_list) {
-		temp = list_entry(pos, struct mdp_hist_lut_mgmt, list);
-		list_del(pos);
-		kfree(temp);
-	}
-	mutex_unlock(&mdp_hist_lut_list_mutex);
-exit:
-	pr_err("Failed initializing histogram LUT memory\n");
-	return -ENOMEM;
-}
-
-static int mdp_hist_lut_block2mgmt(uint32_t block,
-		struct mdp_hist_lut_mgmt **mgmt)
-{
-	struct mdp_hist_lut_mgmt *temp, *output;
-	int ret = 0;
-
-	output = NULL;
-
-	mutex_lock(&mdp_hist_lut_list_mutex);
-	list_for_each_entry(temp, &mdp_hist_lut_list, list) {
-		if (temp->block == block)
-			output = temp;
-	}
-	mutex_unlock(&mdp_hist_lut_list_mutex);
-
-	if (output == NULL)
-		ret = -EINVAL;
-	else
-		*mgmt = output;
-
-	return ret;
-}
-
-#define MDP_HIST_LUT_SIZE (256)
-static int mdp_hist_lut_write_off(struct mdp_hist_lut_data *data,
-		struct mdp_hist_lut_info *info, uint32_t offset)
-{
-	int i;
-	uint32_t element[MDP_HIST_LUT_SIZE];
-	uint32_t base = mdp_block2base(info->block);
-	uint32_t sel = info->bank_sel;
-
-
-	if (data->len != MDP_HIST_LUT_SIZE) {
-		pr_err("%s: data->len != %d", __func__, MDP_HIST_LUT_SIZE);
-		return -EINVAL;
-	}
-
-	if (copy_from_user(&element, data->data,
-				MDP_HIST_LUT_SIZE * sizeof(uint32_t))) {
-		pr_err("%s: Error copying histogram data", __func__);
-		return -ENOMEM;
-	}
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	for (i = 0; i < MDP_HIST_LUT_SIZE; i++)
-		MDP_OUTP(MDP_BASE + base + offset + (0x400*(sel)) + (4*i),
-				element[i]);
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-
-	return 0;
-}
-
-static int mdp_hist_lut_write(struct mdp_hist_lut_data *data,
-						struct mdp_hist_lut_info *info)
-{
-	int ret = 0;
-
-	if (data->block != info->block) {
-		ret = -1;
-		pr_err("%s, data/info mdp_block mismatch! %d != %d\n",
-				__func__, data->block, info->block);
-		goto error;
-	}
-
-	switch (data->block) {
-	case MDP_BLOCK_VG_1:
-	case MDP_BLOCK_VG_2:
-		ret = mdp_hist_lut_write_off(data, info, 0x3400);
-		break;
-	case MDP_BLOCK_DMA_P:
-	case MDP_BLOCK_DMA_S:
-		ret = mdp_hist_lut_write_off(data, info, 0x4800);
-		break;
-	default:
-		ret = -EINVAL;
-		goto error;
-	}
-
-error:
-	return ret;
-}
-
-#define MDP_HIST_LUT_VG_EN_MASK (0x20000)
-#define MDP_HIST_LUT_VG_EN_SHIFT (17)
-#define MDP_HIST_LUT_VG_EN_OFFSET (0x0058)
-#define MDP_HIST_LUT_VG_SEL_OFFSET (0x0064)
-static void mdp_hist_lut_commit_vg(struct mdp_hist_lut_info *info)
-{
-	uint32_t out_en, temp_en;
-	uint32_t base = mdp_block2base(info->block);
-	temp_en = (info->is_enabled) ? (1 << MDP_HIST_LUT_VG_EN_SHIFT) : 0x0;
-
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	out_en = inpdw(MDP_BASE + base + MDP_HIST_LUT_VG_EN_OFFSET) &
-						~MDP_HIST_LUT_VG_EN_MASK;
-	MDP_OUTP(MDP_BASE + base + MDP_HIST_LUT_VG_EN_OFFSET, out_en | temp_en);
-
-	if (info->has_sel_update)
-		MDP_OUTP(MDP_BASE + base + MDP_HIST_LUT_VG_SEL_OFFSET,
-								info->bank_sel);
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-}
-
-#define MDP_HIST_LUT_DMA_EN_MASK (0x7)
-#define MDP_HIST_LUT_DMA_SEL_MASK (0x400)
-#define MDP_HIST_LUT_DMA_SEL_SHIFT (10)
-#define MDP_HIST_LUT_DMA_P_OFFSET (0x0070)
-#define MDP_HIST_LUT_DMA_S_OFFSET (0x0028)
-static void mdp_hist_lut_commit_dma(struct mdp_hist_lut_info *info)
-{
-	uint32_t out, temp, mask;
-	uint32_t base = mdp_block2base(info->block);
-	uint32_t offset = (info->block == MDP_BLOCK_DMA_P) ?
-		MDP_HIST_LUT_DMA_P_OFFSET : MDP_HIST_LUT_DMA_S_OFFSET;
-
-	mask = MDP_HIST_LUT_DMA_EN_MASK;
-	temp = (info->is_enabled) ? 0x7 : 0x0;
-
-	if (info->has_sel_update) {
-		mask |= MDP_HIST_LUT_DMA_SEL_MASK;
-		temp |=  ((info->bank_sel & 0x1) << MDP_HIST_LUT_DMA_SEL_SHIFT);
-	}
-
-	out = inpdw(MDP_BASE + base + offset) & ~mask;
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	MDP_OUTP(MDP_BASE + base + offset, out | temp);
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-}
-
-static void mdp_hist_lut_commit_info(struct mdp_hist_lut_info *info)
-{
-	switch (info->block) {
-	case MDP_BLOCK_VG_1:
-	case MDP_BLOCK_VG_2:
-		mdp_hist_lut_commit_vg(info);
-		break;
-	case MDP_BLOCK_DMA_P:
-	case MDP_BLOCK_DMA_S:
-		mdp_hist_lut_commit_dma(info);
-		break;
-	default:
-		goto error;
-	}
-
-error:
-	return;
-}
-
-static void mdp_hist_lut_update_info(struct mdp_hist_lut_info *info, int ops)
-{
-	info->bank_sel = (ops & 0x8) >> 3;
-	info->is_enabled = (ops & 0x1) ? TRUE : FALSE;
-	info->has_sel_update = (ops & 0x10) ? TRUE : FALSE;
-}
-
-int mdp_hist_lut_config(struct mdp_hist_lut_data *data)
-{
-	struct mdp_hist_lut_mgmt *mgmt = NULL;
-	struct mdp_hist_lut_info info;
-	int ret = 0;
-
-	if (!mdp_pp_block2hist_lut(data->block)) {
-		ret = -ENOTTY;
-		goto error;
-	}
-
-	ret = mdp_hist_lut_block2mgmt(data->block, &mgmt);
-	if (ret)
-		goto error;
-
-	mutex_lock(&mgmt->lock);
-
-	info.block = mgmt->block;
-
-	mdp_hist_lut_update_info(&info, data->ops);
-
-	switch ((data->ops & 0x6) >> 1) {
-	case 0x1:
-		pr_info("%s: histogram LUT read not supported\n", __func__);
-		break;
-	case 0x2:
-		ret = mdp_hist_lut_write(data, &info);
-		if (ret)
-			goto error_lock;
-		break;
-	default:
-		break;
-	}
-
-	mdp_hist_lut_commit_info(&info);
-
-error_lock:
-	mutex_unlock(&mgmt->lock);
-error:
-	return ret;
-}
-
-
 DEFINE_MUTEX(mdp_lut_push_sem);
 static int mdp_lut_i;
 static int mdp_lut_hw_update(struct fb_cmap *cmap)
@@ -1485,12 +1183,12 @@
 static int mdp_off(struct platform_device *pdev)
 {
 	int ret = 0;
-
 	mdp_histogram_ctrl(FALSE);
 
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
 	ret = panel_next_off(pdev);
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+
 	return ret;
 }
 
@@ -1500,12 +1198,9 @@
 
 #ifdef CONFIG_FB_MSM_MDP40
 	struct msm_fb_data_type *mfd;
-	mdp4_overlay_ctrl_db_reset();
-
-	mfd = platform_get_drvdata(pdev);
-
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
 	if (is_mdp4_hw_reset()) {
+		mfd = platform_get_drvdata(pdev);
 		mdp_vsync_cfg_regs(mfd, FALSE);
 		mdp4_hw_init();
 		outpdw(MDP_BASE + 0x0038, mdp4_display_intf);
@@ -1518,13 +1213,6 @@
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 
 	mdp_histogram_ctrl(TRUE);
-#ifdef CONFIG_FB_MSM_MDP40
-	if (mfd->panel.type == MIPI_CMD_PANEL)
-		mdp4_dsi_cmd_overlay_restore();
-	else if (mfd->panel.type == MDDI_PANEL)
-		mdp4_mddi_overlay_restore();
-#endif
-
 	return ret;
 }
 
@@ -1829,9 +1517,6 @@
 	mfd->ov0_blt_state  = 0;
 	mfd->use_ov0_blt = 0 ;
 
-    /* initialize Post Processing data*/
-	mdp_hist_lut_init();
-
 	/* add panel data */
 	if (platform_device_add_data
 	    (msm_fb_dev, pdev->dev.platform_data,
